use std::{path::PathBuf, sync::LazyLock};

use anyhow::{Result, bail};
use clap::{Args, Parser, Subcommand, ValueEnum, builder::PossibleValuesParser};

use crate::exporter::prometheus_exporter::{Labels, PromExportType};

#[derive(Clone, Debug, Parser)]
#[command(name = "bpfmeter", version)]
#[command(about = "Tool for performance measurement of eBPF programs", long_about = None)]
pub struct Config {
    #[command(subcommand)]
    pub command: SubCommands,

    #[arg(short, long, help = "Log Level", default_value = "info", value_parser = PossibleValuesParser::new(["debug", "info", "warn", "error"]))]
    pub log_level: String,
}

#[derive(Clone, Debug, Subcommand)]
pub enum SubCommands {
    /// Run monitoring process
    Run(RunArgs),
    /// Draw results from csv files
    #[cfg(feature = "draw")]
    Draw(DrawArgs),
}

#[derive(Clone, Debug, Args)]
pub struct RunArgs {
    /// Disable cpu usage monitoring
    #[arg(long, default_value_t = false)]
    pub disable_cpu: bool,

    /// List of ebpf program ids to monitor
    #[arg(short='p', long, value_delimiter = ',', num_args(1..))]
    pub bpf_programs: Option<Vec<u32>>,

    /// Period of time between two measurements (ticks) for cpu usage calculation
    #[arg(long, value_parser = duration_parser, default_value = "30s")]
    pub cpu_period: std::time::Duration,

    /// Enable maps usage monitoring
    #[arg(long, default_value_t = false)]
    pub enable_maps: bool,

    #[arg(short='m', long, value_delimiter = ',', num_args(1..))]
    pub bpf_maps: Option<Vec<u32>>,

    /// Period of time between two measurements (ticks) for map stats calculation
    #[arg(long, value_parser = duration_parser, default_value = "30s")]
    pub map_period: std::time::Duration,

    /// Number of measurements to take, if not specified, run indefinitely until Ctrl+C
    #[arg(short, long)]
    pub ticks: Option<u64>,

    /// Advanced: Maximum capacity of the channel between ebpf program monitoring and exporter
    #[arg(short, long, default_value = "1000")]
    pub channel_capacity: usize,

    /// How to export the results
    #[command(flatten)]
    pub output_mode: OutputMode,
}

fn duration_parser(s: &str) -> Result<std::time::Duration> {
    if !s.ends_with("sec") && !s.ends_with("s") && !s.ends_with("msec") && !s.ends_with("ms") {
        bail!(
            "Invalid duration format: {s}, Only seconds and milliseconds are supported (e.g. 1s, 100ms)"
        );
    }
    Ok(humantime::parse_duration(s)?)
}

#[derive(Default, Clone, Debug, Args)]
#[group(required = false, multiple = false)]
pub struct OutputMode {
    /// Output directory to store csv files
    #[arg(short, long, value_parser = check_dir, conflicts_with = "prometheus")]
    pub output_dir: Option<std::path::PathBuf>,

    /// Prometheus exporter arguments
    #[command(flatten)]
    pub prometheus: PrometheusArgs,
}

#[derive(Default, Clone, Debug, Args)]
#[group(id = "prometheus", required = false, multiple = true)]
pub struct PrometheusArgs {
    /// Prometheus exporter port
    #[arg(short = 'P', long, value_parser = clap::value_parser!(u16).range(1..), default_value = "9100")]
    pub port: u16,

    /// Prometheus exporter labels. Format: label1=value1,label2=value2,...
    #[arg(short, long, value_parser = label_parser)]
    pub labels: Option<Labels>,

    /// Prometheus export types
    #[arg(short, long, default_values_t = [PromExportType::RunTime, PromExportType::EventCount], value_delimiter = ',')]
    pub export_types: Vec<PromExportType>,

    /// Prometheus garbage collector interval,set to 0s to disable
    #[arg(long, value_parser = duration_parser, default_value = "30s")]
    pub gc_period: std::time::Duration,
}

fn label_parser(s: &str) -> Result<Labels> {
    let mut labels = Vec::new();
    for label in s.split(',') {
        let mut label = label.split([',', '=']);
        let key = label
            .next()
            .ok_or_else(|| anyhow::anyhow!("Invalid label format: {s}"))?;
        let value = label
            .next()
            .ok_or_else(|| anyhow::anyhow!("Invalid label format: {s}"))?;
        labels.push((key.to_string(), value.to_string()));
    }
    Ok(labels)
}

#[derive(Clone, Debug, Args)]
pub struct DrawArgs {
    /// Input directory with csv files, generated by tool
    #[arg(short, long, value_parser = check_dir)]
    pub input_dir: std::path::PathBuf,

    /// Output directory with images
    #[arg(short, long, value_parser = check_dir)]
    pub output_dir: std::path::PathBuf,

    /// Draw separate chart for each bpf program
    #[arg(short, long)]
    pub multiple: bool,

    /// Draw type: cpu usage or event count
    #[arg(value_enum, short='t', long, default_value_t = DrawType::CPUUsage)]
    pub draw_type: DrawType,
}

#[derive(Clone, Debug, ValueEnum)]
pub enum DrawType {
    CPUUsage,
    EventCount,
    MapSize,
}

fn check_dir(s: &str) -> Result<PathBuf> {
    let path = PathBuf::from(s);
    if !path.is_dir() {
        bail!("Output directory does not exist");
    }
    Ok(path)
}

impl Config {
    fn new() -> Self {
        Self::parse()
    }
}

pub static CONFIG: LazyLock<Config> = LazyLock::new(Config::new);
